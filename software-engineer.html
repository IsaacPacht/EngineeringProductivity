<!-- This is a simulation of a software engineer.  Please see the README.MD for more information -->
<script src="three.js"></script>
<script>
	mgPerHour = 30;
	const nuclearRadius = 0.2 * .3, atomicRadius = 1.0 * .3, textScale = .2, bugScale = .15;

	const reflect = (receiver, operations) => { 
		operations.forEach(x => x(receiver));
		return receiver;
	};

	const sin = (deg) => Math.sin(deg * Math.PI / 180), cos = (deg) => Math.cos(deg * Math.PI / 180), v = (x, y) => new THREE.Vector2(x * textScale, y * textScale);
	const mesh = (geometery, rgb, x, y, z) => new THREE.Mesh(geometery, new THREE.MeshLambertMaterial( { color: rgb } )).translateX(x).translateY(y).translateZ(z);

	const createBit = (value, startTime) => Object.assign(mesh(new THREE.ExtrudeGeometry([ Object.assign(new THREE.Shape([v(-3, +4), v(-2, +5), v(+2, +5), v(+3, +4), v(+3, -4), v(+2, -5), v(-2, -5), v(-3, -4), v(-3, -4)]), { holes: [new THREE.Path([v(-2, +3), v(+2, +3), v(+2, -3), v(-2, -3)])]}), new THREE.Shape([v(-3, +2), v(-3, +3), v(-1, +5), v(+1, +5), v(+1, -4), v(+2, -4), v(+3, -5), v(-3, -5), v(-2, -4), v(-1, -4), v(-1, +3), v(-2, +2)]), reflect(new THREE.Shape([v(0 * bugScale,0 * bugScale)]), [, p => p.moveTo(0 * bugScale,0 * bugScale), p => p.bezierCurveTo(0 * bugScale,-2 * bugScale,3 * bugScale,-2 * bugScale,3 * bugScale,0 * bugScale), p => p.bezierCurveTo(3 * bugScale,2 * bugScale,0 * bugScale,2 * bugScale,0 * bugScale,0 * bugScale), p => p.moveTo(3 * bugScale,-6 * bugScale), p => p.lineTo(5 * bugScale,-8 * bugScale), p => p.lineTo(5 * bugScale,-7 * bugScale), p => p.lineTo(3 * bugScale,-6 * bugScale), p => p.bezierCurveTo(4 * bugScale,-5 * bugScale,4 * bugScale,-5 * bugScale,4 * bugScale,-4 * bugScale), p => p.lineTo(5 * bugScale,-6 * bugScale), p => p.lineTo(6 * bugScale,-5 * bugScale), p => p.bezierCurveTo(5 * bugScale,-5 * bugScale,4 * bugScale,-4 * bugScale,4 * bugScale,-4 * bugScale), p => p.bezierCurveTo(4 * bugScale,-3 * bugScale,4 * bugScale,-3 * bugScale,4 * bugScale,-2 * bugScale), p => p.lineTo(4 * bugScale,-2 * bugScale), p => p.lineTo(5 * bugScale,-3 * bugScale), p => p.lineTo(6 * bugScale,-3 * bugScale), p => p.bezierCurveTo(5 * bugScale,-2 * bugScale,4 * bugScale,-2 * bugScale,4 * bugScale,-1 * bugScale), p => p.bezierCurveTo(4 * bugScale,-1 * bugScale,4 * bugScale,-1 * bugScale,3 * bugScale,-2 * bugScale), p => p.bezierCurveTo(3 * bugScale,-1 * bugScale,3 * bugScale,-1 * bugScale,3 * bugScale,-1 * bugScale), p => p.bezierCurveTo(2 * bugScale,-2 * bugScale,0 * bugScale,-2 * bugScale,0 * bugScale,-1 * bugScale), p => p.bezierCurveTo(0 * bugScale,-1 * bugScale,-0 * bugScale,-1 * bugScale,-0 * bugScale,-2 * bugScale), p => p.bezierCurveTo(-0 * bugScale,-1 * bugScale,-0 * bugScale,-1 * bugScale,-0 * bugScale,-1 * bugScale), p => p.bezierCurveTo(-1 * bugScale,-2 * bugScale,-1 * bugScale,-2 * bugScale,-2 * bugScale,-3 * bugScale), p => p.lineTo(-2 * bugScale,-3 * bugScale), p => p.lineTo(-0 * bugScale,-2 * bugScale), p => p.lineTo(-0 * bugScale,-2 * bugScale), p => p.bezierCurveTo(-0 * bugScale,-3 * bugScale,-0 * bugScale,-3 * bugScale,-0 * bugScale,-4 * bugScale), p => p.bezierCurveTo(-1 * bugScale,-4 * bugScale,-1 * bugScale,-5 * bugScale,-2 * bugScale,-5 * bugScale), p => p.lineTo(-2 * bugScale,-6 * bugScale), p => p.lineTo(-0 * bugScale,-4 * bugScale), p => p.bezierCurveTo(-0 * bugScale,-5 * bugScale,-0 * bugScale,-5 * bugScale,-0 * bugScale,-6 * bugScale), p => p.lineTo(-1 * bugScale,-7 * bugScale), p => p.lineTo(-1 * bugScale,-8 * bugScale), p => p.lineTo(-0 * bugScale,-6 * bugScale), p => p.bezierCurveTo(0 * bugScale,-8 * bugScale,3 * bugScale,-8 * bugScale,3 * bugScale,-6 * bugScale)])][value], { steps: 2, depth: .2, bevelEnabled: true, bevelThickness: .1, bevelSize: .1, bevelOffset: 0, bevelSegments: 1 }), [0x5500ff, 0x00ff00, 0xff0000][value], 3, 0, 0), { isBit: true, startTime });
	const createCaffeineMolecule = (startTime) => {
		let x = 0, y = 0, angle = 0;
		const parts = [], constructors = { "N": () => mesh(new THREE.SphereBufferGeometry(nuclearRadius, 32, 32 ), 0x0000FF, x += atomicRadius * cos(angle), y += atomicRadius * sin(angle), 0), "C": () => mesh(new THREE.SphereBufferGeometry(nuclearRadius, 32, 32 ), 0x000000, x += atomicRadius * cos(angle), y += atomicRadius * sin(angle), 0), "O": () => mesh(new THREE.SphereBufferGeometry(nuclearRadius, 32, 32 ), 0xFF0000, x += atomicRadius * cos(angle), y += atomicRadius * sin(angle), 0), "H": () => mesh(new THREE.SphereBufferGeometry(.6 * nuclearRadius, 32, 32 ), 0xFFFFFF, x += atomicRadius * cos(angle), y += atomicRadius * sin(angle), 0), "M": () => new THREE.Group().add(mesh(new THREE.SphereBufferGeometry(nuclearRadius, 32, 32 ), 0x000000, 0, 0, 0), mesh(new THREE.SphereBufferGeometry(.6 * nuclearRadius, 32, 32 ), 0xFFFFFF, 0.866 * nuclearRadius, .5 * nuclearRadius, .5 * nuclearRadius),mesh(new THREE.SphereBufferGeometry(.6 * nuclearRadius, 32, 32 ), 0xFFFFFF, -0.866 * nuclearRadius, .5 * nuclearRadius, .5 * nuclearRadius),mesh(new THREE.SphereBufferGeometry(.6 * nuclearRadius, 32, 32 ), 0xFFFFFF, 0 * nuclearRadius, .5 * nuclearRadius, -1 * nuclearRadius)).translateX(x += atomicRadius * cos(angle)).translateY(y += atomicRadius * sin(angle)).rotateZ((angle - 90) * Math.PI / 180), ".": () => mesh(new THREE.CylinderGeometry(atomicRadius * .05, atomicRadius * .05, atomicRadius, 32), 0x303030, x, y, 0).rotateZ((90 + angle) * Math.PI / 180).translateY(-atomicRadius / 2), ":": () => [.04 * atomicRadius, -.04 * atomicRadius].map(offset => mesh(new THREE.CylinderGeometry(atomicRadius * .05, atomicRadius * .05, atomicRadius, 32), 0x303030, x, y, 0).rotateZ((90 + angle) * Math.PI / 180).translateY(-atomicRadius / 2).translateX(offset * cos(angle != 195 ? 90+angle : angle)).translateY(offset * sin(angle))) };
		[...new Array(54).fill(/([NCOHM:.])|(\d+)|(<\d+)/g)].map(regex => regex.exec("N 30 . C 330 . C 270 : C 210 . N 150 . C 90 . <3 90:O <6 20.N 310.C 230:N 165. <15 195:O <28 0.H <0 150.M <12 270.M <25 70.M")).forEach(instruction => { reflect(instruction, [ instruction => angle = instruction[2] ? parseInt(instruction[2]) : angle, instruction => x = instruction[3] ? parts[parseInt(instruction[3].substring(1))].position.x : x, instruction => y = instruction[3] ? parts[parseInt(instruction[3].substring(1))].position.y : y, instruction => parts.push(instruction[1] ? constructors[instruction[1]]() : null)]) });
		return Object.assign(new THREE.Group().add(...parts.flat().filter(x => x != null)).translateX(-100).translateY(Math.floor(Math.random() * 4 - 2)).translateZ(Math.floor(Math.random() * 3 - 1.5)), { isCaffeine: true, startTime, xrot: Math.random() >= .5 ? 1 : -1 });
	};
	
	const scene = new THREE.Scene().add(new THREE.Group().add(mesh(new THREE.CylinderGeometry(3, 1, 2, 32, 1, true), 0xFF00FF, -3, 0, 0).rotateZ(Math.PI / 2), mesh(new THREE.CylinderGeometry(3, 1, 2, 32, 1, true), 0xFF00FF, 3, 0, 0).rotateZ(-Math.PI / 2), mesh(new THREE.CylinderGeometry(1, 1, 4, 32, 1, true), 0xFF00FF, 0, 0, 0).rotateZ(-Math.PI / 2)), new THREE.PointLight(0xffffff, 3, 0).translateY(50).translateZ(20), mesh(new THREE.PlaneBufferGeometry(200, 200), 0x808080, 0, -5, 0).rotateX(- Math.PI / 2), mesh(new THREE.PlaneBufferGeometry(200, 200), 0x808080, 0, 0, -55), ...[1, 2, 3, 4, 5, 6].map(n => createCaffeineMolecule(n * -2000)));
	const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000).translateY(1).translateZ(10);
	const renderer = reflect(new THREE.WebGLRenderer({antialias: true}), [x => x.setSize(window.innerWidth, window.innerHeight), x => x.setAnimationLoop(t => reflect(scene.children, [c => c.filter(x => x.isCaffeine).map(m => m.translateX((t - m.startTime) * .0001 * mgPerHour - 20 - m.position.x).rotateX(.0001 * mgPerHour * 10 * m.xrot)).filter(m => m.position.x >= -4.6).forEach(m=> scene.remove(m)), c => c.filter(x => x.isCaffeine).length < 10 ? scene.add(createCaffeineMolecule(t)) : null, c => c.filter(x => x.isBit).map(m => m.translateX((t - m.startTime) * .0001 * mgPerHour * 1 + 3 - m.position.x)).filter(m => m.position.x >= 15 || m.position.x < 3).forEach(m => scene.remove(m)), c => c.filter(x => x.isBit).length === 0 || scene.children.filter(x => x.isBit).length < 5 && Math.min(...(scene.children.filter(x => x.isBit).map(x => x.position.x))) > 5 ?  scene.add(createBit(Math.random() < Math.max(0, ((100 - mgPerHour) / 300 )) ? 2 : Math.floor(Math.random() +.5), t)) : null ], renderer.render(scene, camera)))]);
	reflect(document, [ d => d.documentElement.appendChild(document.createElement("body")).appendChild(renderer.domElement), d => d.body.appendChild(Object.assign(document.createElement("div"), { id: "a" }))]);
	const updateStatus = (increment) => document.getElementById("a").innerHTML = `<div id="a" style="background-color: black; color: white; font-size: 30pt; position: absolute; top: 50px; left: 50px; z-index: 100;">Caffeine intake rate: ${mgPerHour = Math.min(100, Math.max(0, mgPerHour + increment))} mg/hour <button style="font-size: 60pt; height: 100px; width: 100px" onclick="updateStatus(1)">&#x2B06;</button> <button style="font-size: 60pt; height: 100px; width: 100px" onclick="updateStatus(-1)">&#x2B07;</button><br>Code throughput: ${Math.round(mgPerHour / 12 * 100) / 100} bps<br>Bug ratio: ${Math.round(Math.max(0, ((100 - mgPerHour) / 3 )))}%</div>`;
	updateStatus(0);
</script>
